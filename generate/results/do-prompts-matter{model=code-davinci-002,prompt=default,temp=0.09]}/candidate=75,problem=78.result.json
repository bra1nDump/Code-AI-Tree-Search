{
    "codes": [
        "\n# Solution\n\n# This solution is based on the idea that we can use dynamic programming to solve this problem.\n# We will use a 2D array to store the number of ways to reach a certain duration with a certain genre.\n# The first dimension will be the duration and the second dimension will be the genre.\n# We will use the following formula to calculate the number of ways to reach a certain duration with a certain genre:\n# dp[duration][genre] = dp[duration - song_duration][genre] + dp[duration - song_duration][genre - 1] + dp[duration - song_duration][genre + 1]\n# The first term in the above formula is the number of ways to reach the current duration with the current genre by using the current song.\n# The second term is the number of ways to reach the current duration with the current genre by using the current song and the previous song.\n# The third term is the number of ways to reach the current duration with the current genre by using the current song and the next song.\n# We will use the above formula to calculate the number of ways to reach a certain duration with a certain genre.\n# We will use the following formula to calculate the answer:\n# answer = dp[duration][1] + dp[duration][2] + dp[duration][3]\n# The first term in the above formula is the number of ways to reach the current duration with the first genre.\n# The second term is the number of ways to reach the current duration with the second genre.\n# The third term is the number of ways to reach the current duration with the third genre.\n# We will use the above formula to calculate the answer.\n\n# Time complexity: O(n * T)\n# Space complexity: O(T)\n\nMOD = 10 ** 9 + 7\n\ndef solve(n, T, songs):\n    dp = [[0 for _ in range(4)] for _ in range(T + 1)]\n    dp[0][1] = 1\n    dp[0][2] = 1\n    dp[0][3] = 1\n    for duration in range(1, T + 1):\n        for genre in range(1, 4):\n            for song in songs:\n                if duration - song[0] >= 0:\n                    dp[duration][genre] += dp[duration - song[0]][genre]\n                    if genre - 1 >= 1:\n                        dp[duration][genre] += dp[duration - song[0]][genre - 1]\n                    if genre + 1 <= 3:\n                        dp[duration][genre] += dp[duration - song[0]][genre + 1]\n                    dp[duration][genre] %= MOD\n    answer = 0\n    for genre in range(1, 4):\n        answer += dp[T][genre]\n        answer %= MOD\n    return answer\n\nif True:\n    n, T = map(int, input().split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, input().split())\n        songs.append((t, g))\n    print(solve(n, T, songs))"
    ],
    "rewards": [
        0.03636363636363636
    ],
    "train rewards": [
        0.12962962962962962
    ],
    "time": 17.212548971176147,
    "sample times": 2,
    "test_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
        ]
    ],
    "train_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
        ]
    ]
}