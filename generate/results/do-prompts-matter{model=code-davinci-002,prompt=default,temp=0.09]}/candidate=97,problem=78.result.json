{
    "codes": [
        "\n# Solution 1\n# This solution is based on the observation that the number of playlists of length $T$ is equal to the sum of the number of playlists of length $T-t_i$ for all $i$ such that $t_i \\le T$.\n# This is because we can append any song of length $t_i$ to any playlist of length $T-t_i$ to get a playlist of length $T$.\n# This is a recursive solution, but we can use memoization to make it run in $O(nT)$ time.\n# The base case is when $T=0$, in which case there is only one playlist of length $0$, which is the empty playlist.\n# The recursive case is when $T>0$, in which case we can add any song of length $t_i$ to any playlist of length $T-t_i$ to get a playlist of length $T$.\n# We can use memoization to store the number of playlists of length $T$ for each $T$ in a list.\n# We can also use memoization to store the number of playlists of length $T$ for each $T$ and each genre $g$ in a dictionary.\n# This is because we can't have two consecutive songs of the same genre, so we need to keep track of the genre of the last song in the playlist.\n# We can use the same idea to keep track of the last two songs in the playlist, but this is not necessary.\n# The time complexity is $O(nT)$ and the space complexity is $O(nT)$.\n\ndef numPlaylists(n, T, songs):\n    # Initialize the memoization lists.\n    # The first list stores the number of playlists of length $T$ for each $T$.\n    # The second list stores the number of playlists of length $T$ for each $T$ and each genre $g$.\n    # The base case is when $T=0$, in which case there is only one playlist of length $0$, which is the empty playlist.\n    # The recursive case is when $T>0$, in which case we can add any song of length $t_i$ to any playlist of length $T-t_i$ to get a playlist of length $T$.\n    # We can use memoization to store the number of playlists of length $T$ for each $T$ in a list.\n    # We can also use memoization to store the number of playlists of length $T$ for each $T$ and each genre $g$ in a dictionary.\n    # This is because we can't have two consecutive songs of the same genre, so we need to keep track of the genre of the last song in the playlist.\n    # We can use the same idea to keep track of the last two songs in the playlist, but this is not necessary.\n    # The time complexity is $O(nT)$ and the space complexity is $O(nT)$.\n    playlists = [1] + [0] * T\n    playlistsByGenre = [{} for _ in range(T+1)]\n    playlistsByGenre[0][0] = 1\n    for t in range(1, T+1):\n        for i in range(n):\n            t_i, g_i = songs[i]\n            if t_i <= t:\n                playlists[t] += playlists[t-t_i]\n                for g in playlistsByGenre[t-t_i]:\n                    if g != g_i:\n                        if g_i not in playlistsByGenre[t]:\n                            playlistsByGenre[t][g_i] = 0\n                        playlistsByGenre[t][g_i] += playlistsByGenre[t-t_i][g]\n    return playlists[T]\n\n# Solution 2\n# This solution is based on the observation that the number of playlists of length $T$ is equal to the sum of the number of playlists of length $T-t_i$ for all $i$ such that $t_i \\le T$.\n# This is because we can append any song of length $t_i$ to any playlist of length $T-t_i$ to get a playlist of length $T$.\n# This is a recursive solution, but we can use memoization to make it run in $O(nT)$ time.\n# The base case is when $T=0$, in which case there is only one playlist of length $0$, which is the empty playlist.\n"
    ],
    "rewards": [
        0.0
    ],
    "train rewards": [
        0.0
    ],
    "time": 19.15312099456787,
    "sample times": 2,
    "test_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
        ]
    ],
    "train_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false
        ]
    ]
}