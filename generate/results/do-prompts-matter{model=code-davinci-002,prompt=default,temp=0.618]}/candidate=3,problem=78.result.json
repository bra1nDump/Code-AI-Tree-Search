{
    "codes": [
        "\n\"\"\"\n    This solution is inspired by the solution of \"C. Way to Home\" problem.\n    The idea is to find the number of ways to sort a list of integers such that\n    they are in ascending order, and there are no two consecutive integers \n    with the same value.\n\"\"\"\n\n\"\"\"\n    This solution is inspired by the solution of \"C. Way to Home\" problem.\n    The idea is to find the number of ways to sort a list of integers such that\n    they are in ascending order, and there are no two consecutive integers \n    with the same value.\n\"\"\"\n\n\"\"\"\n    This solution is inspired by the solution of \"C. Way to Home\" problem.\n    The idea is to find the number of ways to sort a list of integers such that\n    they are in ascending order, and there are no two consecutive integers \n    with the same value.\n\"\"\"\n\n\"\"\"\n    This solution is inspired by the solution of \"C. Way to Home\" problem.\n    The idea is to find the number of ways to sort a list of integers such that\n    they are in ascending order, and there are no two consecutive integers \n    with the same value.\n\"\"\"\n\n\"\"\"\n    This solution is inspired by the solution of \"C. Way to Home\" problem.\n    The idea is to find the number of ways to sort a list of integers such that\n    they are in ascending order, and there are no two consecutive integers \n    with the same value.\n\"\"\"\n\nif True:\n    n, T = [int(x) for x in input().split()]\n    songs = [[int(x) for x in input().split()] for i in range(n)]\n    mod = 1000000007\n    # dp[i][j][k] denotes the number of ways to sort the first i songs such that\n    # the sum of their durations is j and the last genre is k.\n    dp = [[[0 for k in range(4)] for j in range(T + 1)] for i in range(n + 1)]\n    # Base cases\n    for i in range(1, n + 1):\n        dp[i][0][0] = 1\n    for j in range(1, T + 1):\n        dp[0][j][0] = 0\n    for i in range(1, n + 1):\n        for j in range(1, T + 1):\n            for k in range(1, 4):\n                if j >= songs[i - 1][0]:\n                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i - 1][j - songs[i - 1][0]][songs[i - 1][1]]) % mod\n                else:\n                    dp[i][j][k] = dp[i - 1][j][k]\n    print(dp[n][T][0])"
    ],
    "rewards": [
        0.43636363636363634
    ],
    "train rewards": [
        0.3888888888888889
    ],
    "time": 15.175752878189087,
    "sample times": 2,
    "test_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            true,
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            true,
            true,
            true,
            true,
            true,
            false,
            true,
            true,
            true,
            true,
            true,
            false,
            true,
            true,
            false,
            true,
            true,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            false,
            true
        ]
    ],
    "train_rewards": [
        [
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            true,
            false,
            false,
            true,
            true,
            false,
            false,
            true,
            true,
            true,
            true,
            false,
            true,
            true,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
            false,
            false,
            false,
            false,
            true,
            false,
            true,
            true,
            true,
            true,
            false,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
            false,
            true,
            false,
            false,
            true,
            false,
            false,
            false
        ]
    ]
}